package com.example.algorithm.tree;

public class Test1 {
    public static void main(String[] args) {


        //二叉树
        TreeNode nodeA = new TreeNode("A");
        TreeNode nodeB = new TreeNode("B");
        TreeNode nodeC = new TreeNode("C");
        TreeNode nodeD = new TreeNode("D");
        TreeNode nodeE = new TreeNode("E");
        TreeNode nodeF = new TreeNode("F");
        TreeNode nodeG = new TreeNode("G");
        TreeNode nodeH = new TreeNode("H");


        nodeA.left = nodeB;
        nodeA.right = nodeC;
        nodeB.left = nodeD;
        nodeB.right = nodeE;
        nodeC.right = nodeF;
        nodeF.left = nodeG;
        nodeF.right = nodeH;

        //traverse 遍历
        //recursive 递归
        recursive(nodeA);

        mirror(nodeA);
        System.out.println("");
        recursive(nodeA);

        /**
         *=================================================
         *  二叉树的定义：
         *
         *  二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，
         *  二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2i-1个结点；
         *  深度为k的二叉树至多有2k-1个结点；对任何一棵二叉树T，
         *  如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。
         *
         * 满二叉树
         * 　满二叉树的性质：
         *
         * 　　1) 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;
         *
         * 　　2) 叶子数为2h;
         *
         * 　　3) 第k层的结点数是：2k-1;
         *
         * 　　4) 总结点数是：2k-1，且总节点数一定是奇数。
         *
         *
         * 完全二叉树
         * 完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层)
         * 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。
         *
         *==========================================================
         *二叉查找树
         *二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
         *
         * 　　1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
         *
         * 　　2) 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
         *
         * 　　3) 左、右子树也分别为二叉排序树；
         *
         * 　　4) 没有键值相等的节点。
         *
         * 二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列
         *
         * 二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度
         *
         * ======================================================
         * 平衡二叉树
         * 平衡二叉树定义：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1
         *
         * 平衡查找树之AVL树
         *
         * 平衡二叉树之红黑树
         * 　　红黑树的性质：
         *
         * 　　红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:
         *
         * 　　性质1. 节点是红色或黑色。
         *
         * 　　性质2. 根是黑色。
         *
         * 　　性质3. 所有叶子都是黑色（叶子是NIL节点）。
         *
         * 　　性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)
         *
         * 　　性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
         *
         *
         * ====================================================
         *  B树
         *  B树的定义：B树也是一种用于查找的平衡树，但是它不是二叉树
         *  B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、
         *  循序存取、插入数据及删除的动作，都在对数时间内完成
         *
         * 　B树作为一种多路搜索树（并不是二叉的）：
         *
         * 　　1) 定义任意非叶子结点最多只有M个儿子；且M>2；
         *
         * 　　2) 根结点的儿子数为[2, M]；
         *
         * 　　3) 除根结点以外的非叶子结点的儿子数为[M/2, M]；
         *
         * 　　4) 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
         *
         * 　　5) 非叶子结点的关键字个数=指向儿子的指针个数-1；
         *
         * 　　6) 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
         *
         * 　　7) 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，
         *        其它P[i]指向关键字属于(K[i-1], K[i])的子树；
         *
         * 　　8) 所有叶子结点位于同一层；
         *
         *
         *   B-树:
         *
         * 　B+树是B树的变体，也是一种多路搜索树：
         *
         * 　　1) 其定义基本与B-树相同，除了：
         *
         * 　　2) 非叶子结点的子树指针与关键字个数相同；
         *
         * 　　3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
         *
         * 　　4) 为所有叶子结点增加一个链指针；
         *
         * 　　5) 所有关键字都在叶子结点出现；
         *
         *   B*树
         *
         * Tire树称为字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。
         * 典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。
         * 它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。　
         *
         *
         *
         * 一、B树的应用
         *
         *
         * B树大量应用在数据库和文件系统当中。
         * 假定一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据，如果换成二叉查找树，
         * 则需要20层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在100万个数据中查找目标值，只需要读取两次硬盘。
         *
         *
         * 二、B+树的应用
         *
         * mysql使用B+树作为索引：
         *
         */


        //二叉查找树的左子树上的结点不比父结点大，右子树上的结点不比父结点小
    }

    //二叉树镜像反转
    private static void mirror(TreeNode node) {
        if (node == null) {
            return;
        }

        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
        mirror(node.left);
        mirror(node.right);
    }

    private static void recursive(TreeNode node) {
        if (node == null) {
            return;
        }
        System.out.print("" + node.data); //先
        recursive(node.left);
        // System.out.print("" + node.data); //中
        recursive(node.right);
        //System.out.print("" + node.data); //后

    }


    /**
     *
     *
     *    A
     *   / \
     *  B   C
     *  /\   \
     * D  E   F
     *       /\
     *      G  H
     *
     *         A
     *        / \
     *       C   B
     *       /  /\
     *      F  E  D
     *     /\
     *    H  G
     *
     * 先序遍历：遍历顺序规则为【根左右】 ABDECFGH
     * 中序遍历：遍历顺序规则为【左根右】 DBEACGFH
     * 后序遍历：遍历顺序规则为【左右根】 DEBGHFCA
     *
     *         A
     *        / \
     *       B   E
     *       \   \
     *        C   F
     *       /   /
     *      D   G
     *         /\
     *        H K
     * 先序遍历：ABCDEFGHK
     *
     * 中序遍历：BDCAEHGKF
     *
     * 后序遍历：DCBHKGFEA
     */
}
